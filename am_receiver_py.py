# -*- coding: utf-8 -*-
"""AM_Receiver.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qjirk3i8FNlY-gnPXd56vpBI_bGnxf0v
"""

# Implementation and Testing of AM Receiver -  by Moradeke Olumogba
# 1. Signals Generation (message and AM signal)
# 2. Envelope detection receiver creation

import numpy as np # for sine and cosine functions, etc
from scipy.io import wavfile # for conversion to .wav
import matplotlib.pyplot as plt # for plotting
from scipy.fft import fft, ifft # for frequency domain transformations
import cmath # complex math
import math


# 1. Signals Generation
# Simulation inputs
F_s = 8000 # sampling frequency
F_m = 180 # message frequency
A_m = 0.5 # message amplitude
B = 1 # Bias (offset)
F_c = 2000 # carrier Frequency
A_c = 1 # carrier Amplitude
t = 100 # length of signal in seconds

# For time vector
Number_of_points = round(t*F_s) # round to 1 decimal
print("Number of points=", Number_of_points)

# time_v = range(t) # time vector

# message signal
def message_signal(A_m, F_m, time_v):
  return A_m*np.cos(2*np.pi*F_m*time_v)

# carrier signal
def carrier_signal(F_c, time_v):
  return np.cos(2*np.pi*F_c*time_v)

# AM modulated signal
def modulated_signal(A_c, B, message, carrier):
  return A_c*(B + message)*carrier

# The receiver for envelope detection
def receiver(signal, time_v, F_c,F_s): # using square law
  sqr = signal ** 2
  lowpass_filt = np.linspace(0,2*np.pi*F_c, int(Number_of_points*F_c/F_s))
  # print('lowpass filt length before = ', len(lowpass_filt))
  # print(lowpass_filt)
  zero_pad = 0 * np.linspace(2*np.pi*F_c,2*np.pi*F_s, int(Number_of_points)-len(lowpass_filt))
  lowpass_filt = np.concatenate((lowpass_filt, zero_pad), axis=None)
  #print('zeropad size = ', len(zero_pad))
  #print('lowpass_filt length after = ', len(lowpass_filt))
  #print(lowpass_filt)
  transform = fft(sqr) * lowpass_filt
  transform = ifft(transform)
  transform = transform ** 0.5
  return transform



# Create a notch-filter to remove the DC bias
#def notch_filt(signal, f, F_s,r):
#  notched = fft(signal) * ((1+r)/2) * (1 - cmath.exp(-2*np.pi*f*1j))/(1-r*cmath.exp(-2*np.pi*f*1j))
#  return ifft(notched) # return in time domain







# main testing example
#time = range(100) # time vector
t = np.linspace(0,100,Number_of_points) # time vector
# n = np.linspace(0,Number_of_points-1) # discrete time
# Generate the signal to a wav file, then pass through to the receiver
message_s = message_signal(0.5, 180, t) # create a message signal
carrier_s = carrier_signal(2000, t) # create a carrier signal
modulated_s = modulated_signal(1, 1, message_s, carrier_s) # generate the AM signal
wavfile.write('AM.wav', F_s, modulated_s) # convert to wav file

# To visualize signals so comparison with original can be made at the end
plt.figure, plt.plot(t[:400], modulated_s[:400])
plt.figure, plt.plot(t[:400], message_s[:400])

# n = t*F_s # convert to discrete time

# Put into receiver sub-routine
Received = receiver(modulated_s,t,F_c,F_s)
# Remove DC bias through notch filter
# reconstructed_message = notch_filt(Received,n,F_s,10000)

# To check for reconstructed message, to see if same as message
plt.figure, plt.plot(t[:400], 0.3*Received[:400]) # overlap the plots and diminish recovery by half to view shape clearly

"""The orange represents the message whereas the blue represents the modulated AM signal"""



